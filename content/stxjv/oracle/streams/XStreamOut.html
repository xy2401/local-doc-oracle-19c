<!-- NewPage -->
<!DOCTYPE html>
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_181) on Mon Jan 07 09:53:14 PST 2019 -->
<title>XStreamOut (Oracle Database XStream Java API Reference)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="date" content="2019-01-07">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<meta name="generator" content="Oracle ST-Doc Jadey 2.5">

    <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
    <meta name="dcterms.created" content="2019-02-19T09:04:03+00:00">
    <meta name="dcterms.title" content="Oracle® Database XStream Java API Reference">
    <meta name="dcterms.category" content="database">
    <meta name="dcterms.isVersionOf" content="STXJV">
    <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
    <meta name="dcterms.identifier" content="E96285-02">
    <meta name="dcterms.release" content="Release 19">
  <script id="ssot-metadata" type="application/json"> {"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}} </script>
    </head>
<body>
<script type="text/javascript">
<!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="XStreamOut (Oracle Database XStream Java API Reference)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script> <noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="topNav"><a name="navbar_top" id="navbar_top"><!--   --></a>
<div class="skipNav"><a href="#skip_navbar_top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar_top_firstrow" id="navbar_top_firstrow"><!--   --></a>
<ul class="navList" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><b>Oracle® Database XStream Java API Reference<br>
19c</b><br>
E96285-02</div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="XStreamLCRCallbackHandler.html" title="interface in oracle.streams"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="XStreamUtility.html" title="class in oracle.streams"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html" target="_top">Frames</a></li>
<li><a href="XStreamOut.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript">
<!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script></div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip_navbar_top" id="skip_navbar_top"><!--   --></a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">oracle.streams</div>
<h2 title="Class XStreamOut" class="title">Class XStreamOut</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>oracle.streams.XStreamOut</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">XStreamOut</span>
extends java.lang.Object</pre>
<div class="block">The XStreamOut class provides APIs for using Oracle XStream Out. This is the main Java API for Oracle XStream Out. It contains several main API methods as shown in the list.<br>
<ul>
<li>Attach(): Attach to an XStream outbound server.</li>
<li>Detach(): Detach from an XStream outbound server.</li>
<li>ReceiveLCR(): Receive one LCR from the XStream outbound server in non-callback mode.</li>
<li>ReceiveChunk(): Retrieve chunk data in non-callback mode. Invoke this API after ReceiveLCR() if the LCR contains LOB, LONG, or XMLTYPE data.</li>
<li>ReceiveLCRCallback(): Receive a stream of LCRs from the XStream outbound server in callback mode. You can specify an XStreamLCRCallbackHandler to process the LCRs received from the XStream outbound server.</li>
</ul>
<p>Here is an example of using the callback API:<br></p>
<pre>
   Connection conn;
   XStreamOut xsOut;
   ...

   // assume myLCRHandler implements XStreamLCRCallbackHandler and 
   XStreamLCRCallbackHandler hdlr = new MyLCRHandler(); 

   try
   {
     DriverManager.registerDriver(new oracle.jdbc.OracleDriver());
     conn = DriverManager.getConnection("jdbc:oracle:oci:@hostname:port:sid",
                                        "strmadm", "strmadm");
     xsOut = XStreamOut.attach(conn, new String("APPLY1"),
                               lastPosition, 
                               XStreamOut.ATTACH_APP_CONTAINER_MODE + 
                               XStreamOut.ATTACH_EXTENDED_ID_MODE);  
     while(true) 
     {
       xsOut.receiveLCRCallback(hdlr, XStreamOut.DEFAULT_MODE);
       maintainWatermark();
       ... 
       if (user_terminate_condition)
       {
         break; 
       }
     }
     xsOut.detach(XStreamOut.DEFAULT_MODE);
     } 
   }
   catch(StreamsException e)
   {
      System.out.println("Streams exception: " + e.getMessage()); 
   }
   catch(Exception e)
   {
   }
 </pre>
Please see processLCR() and processChunk() in XStreamLCRCallbackHandler for examples of implementing the callback methods.<br>
<br>
<p>Here is an example of using the non-callback API:<br></p>
<pre>
   Connection conn;
   XStreamOut xsOut;
   ...

   try
   {
     DriverManager.registerDriver(new oracle.jdbc.OracleDriver());
     conn = DriverManager.getConnection("jdbc:oracle:oci:@hostname:port:sid",
                                        "strmadm", "strmadm");
     xsOut = XStreamOut.attach(conn, new String("APPLY1"),
                               lastPosition, 
                               XStreamOut.ATTACH_APP_CONTAINER_MODE + 
                               XStreamOut.ATTACH_EXTENDED_ID_MODE);  
     while(true) 
     {
       LCR alcr = xsOut.receiveLCR(XStreamOut.DEFAULT_MODE);
       if (xsOut.getBatchStatus == EXECUTING) // system is active
       {
         maintainWatermark();
         // ... process LCR header
         if (alcr instanceof RowLCR)
         {
           // ... process scalar columns
           // process chunk data using receiveChunk() API
           if (((RowLCR)alcr).hasChunkData())
           {
             do
             {
               ChunkColumnValue chunk = xsOut.receiveChunk(DEFAULT_MODE);
               // process the Chunk
             } while (!chunk.isEndOfRow())
           }  
         } 
       }
       else // system is idle
       {
         maintainWatermark();
         if (user_terminate_condition)
         {
           break; 
         }
       }
     }
     xsOut.detach(XStreamOut.DEFAULT_MODE);
     } 
   }
   catch(StreamsException e)
   {
      System.out.println("Streams exception: " + e.getMessage()); 
   }
   catch(Exception e)
   {
   }
   
 </pre>
<br></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList"><!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary" id="field_summary"><!--   --></a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#ATTACH_APP_CONTAINER_MODE">ATTACH_APP_CONTAINER_MODE</a></span></code>
<div class="block">This attach mode captures application container statements.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#ATTACH_EXTENDED_ID_MODE">ATTACH_EXTENDED_ID_MODE</a></span></code>
<div class="block">This attach mode returns transaction ID using extended format, "pdb_id.nn.nn.nn".</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#DEFAULT_BATCH_INTERVAL">DEFAULT_BATCH_INTERVAL</a></span></code>
<div class="block">XStreamOut default acknowledge interval value for batch processing</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#DEFAULT_IDLE_TIMEOUT">DEFAULT_IDLE_TIMEOUT</a></span></code>
<div class="block">XStreamOut default timeout value for idle processing</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#DEFAULT_MODE">DEFAULT_MODE</a></span></code>
<div class="block">XStreamOut default mode</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#EXECUTING">EXECUTING</a></span></code>
<div class="block">XStreamOut batch processing status EXECUTING, which indicates the the batch is in progress</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#FINISHED">FINISHED</a></span></code>
<div class="block">XStreamOut batch processing status FINISHED, which is the default status</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#NEW_COLUMN_ONLY_MODE">NEW_COLUMN_ONLY_MODE</a></span></code>
<div class="block">This column list mode allows users to receive LCRs with only new columns in the new value list.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary" id="method_summary"><!--   --></a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static <a href="XStreamOut.html" title="class in oracle.streams">XStreamOut</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#attach_oracle_jdbc_OracleConnection_java_lang_String_byte_A_int_">attach</a></span>(oracle.jdbc.OracleConnection&nbsp;oconn, java.lang.String&nbsp;serverName, byte[]&nbsp;lastPosition, int&nbsp;mode)</code>
<div class="block">Attaches to outbound server.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static <a href="XStreamOut.html" title="class in oracle.streams">XStreamOut</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#attach_oracle_jdbc_OracleConnection_java_lang_String_byte_A_int_int_int_">attach</a></span>(oracle.jdbc.OracleConnection&nbsp;oconn, java.lang.String&nbsp;serverName, byte[]&nbsp;lastPosition, int&nbsp;batchInterval, int&nbsp;idleTimeout, int&nbsp;mode)</code>
<div class="block">Attaches to outbound server.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#detach_int_">detach</a></span>(int&nbsp;mode)</code>
<div class="block">Detaches from outbound server.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#getBatchStatus__">getBatchStatus</a></span>()</code>
<div class="block">Gets batch status.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>byte[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#getFetchLowWatermark__">getFetchLowWatermark</a></span>()</code>
<div class="block">Gets fetch low watermark.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="ChunkColumnValue.html" title="interface in oracle.streams">ChunkColumnValue</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#receiveChunk_int_">receiveChunk</a></span>(int&nbsp;mode)</code>
<div class="block">Receives chunk data in non-callback mode.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="LCR.html" title="interface in oracle.streams">LCR</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#receiveLCR_int_">receiveLCR</a></span>(int&nbsp;mode)</code>
<div class="block">Receives one LCR in non-callback mode.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#receiveLCRCallback_oracle_streams_XStreamLCRCallbackHandler_int_">receiveLCRCallback</a></span>(<a href="XStreamLCRCallbackHandler.html" title="interface in oracle.streams">XStreamLCRCallbackHandler</a>&nbsp;handler, int&nbsp;mode)</code>
<div class="block">Receives a stream of LCRs in callback mode.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#setProcessedLowWatermark_byte_A_byte_A_int_">setProcessedLowWatermark</a></span>(byte[]&nbsp;processedLowWatermark, byte[]&nbsp;oldestPosition, int&nbsp;mode)</code>
<div class="block">Sets processed low watermark.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="XStreamOut.html#setProcessedLowWatermark_byte_A_int_">setProcessedLowWatermark</a></span>(byte[]&nbsp;processedLowWatermark, int&nbsp;mode)</code>
<div class="block">Sets processed low watermark.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java_lang_Object" id="methods_inherited_from_class_java_lang_Object"><!--   --></a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList"><!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail" id="field_detail"><!--   --></a>
<h3>Field Detail</h3>
<a name="DEFAULT_MODE" id="DEFAULT_MODE"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>DEFAULT_MODE</h4>
<pre>public static final int DEFAULT_MODE</pre>
<div class="block">XStreamOut default mode</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#oracle_streams_XStreamOut_DEFAULT_MODE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NEW_COLUMN_ONLY_MODE" id="NEW_COLUMN_ONLY_MODE"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>NEW_COLUMN_ONLY_MODE</h4>
<pre>public static final int NEW_COLUMN_ONLY_MODE</pre>
<div class="block">This column list mode allows users to receive LCRs with only new columns in the new value list.<br>
By default XStreamOut returns the union of new columns and old columns that are not present in the new column list. This mode is valid for receiveLCR and receiveLCRCallback APIs.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#oracle_streams_XStreamOut_NEW_COLUMN_ONLY_MODE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DEFAULT_BATCH_INTERVAL" id="DEFAULT_BATCH_INTERVAL"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>DEFAULT_BATCH_INTERVAL</h4>
<pre>public static final int DEFAULT_BATCH_INTERVAL</pre>
<div class="block">XStreamOut default acknowledge interval value for batch processing</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#oracle_streams_XStreamOut_DEFAULT_BATCH_INTERVAL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DEFAULT_IDLE_TIMEOUT" id="DEFAULT_IDLE_TIMEOUT"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>DEFAULT_IDLE_TIMEOUT</h4>
<pre>public static final int DEFAULT_IDLE_TIMEOUT</pre>
<div class="block">XStreamOut default timeout value for idle processing</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#oracle_streams_XStreamOut_DEFAULT_IDLE_TIMEOUT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FINISHED" id="FINISHED"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>FINISHED</h4>
<pre>public static final int FINISHED</pre>
<div class="block">XStreamOut batch processing status FINISHED, which is the default status</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#oracle_streams_XStreamOut_FINISHED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="EXECUTING" id="EXECUTING"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>EXECUTING</h4>
<pre>public static final int EXECUTING</pre>
<div class="block">XStreamOut batch processing status EXECUTING, which indicates the the batch is in progress</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#oracle_streams_XStreamOut_EXECUTING">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="ATTACH_APP_CONTAINER_MODE" id="ATTACH_APP_CONTAINER_MODE"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>ATTACH_APP_CONTAINER_MODE</h4>
<pre>public static final int ATTACH_APP_CONTAINER_MODE</pre>
<div class="block">This attach mode captures application container statements.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#oracle_streams_XStreamOut_ATTACH_APP_CONTAINER_MODE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="ATTACH_EXTENDED_ID_MODE" id="ATTACH_EXTENDED_ID_MODE"><!--   --></a>
<ul class="blockListLast">
<li class="blockList">
<h4>ATTACH_EXTENDED_ID_MODE</h4>
<pre>public static final int ATTACH_EXTENDED_ID_MODE</pre>
<div class="block">This attach mode returns transaction ID using extended format, "pdb_id.nn.nn.nn".</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../constant-values.html#oracle_streams_XStreamOut_ATTACH_EXTENDED_ID_MODE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail" id="method_detail"><!--   --></a>
<h3>Method Detail</h3>
<a name="attach_oracle_jdbc_OracleConnection_java_lang_String_byte_A_int_" id="attach_oracle_jdbc_OracleConnection_java_lang_String_byte_A_int_"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>attach</h4>
<pre>public static <a href="XStreamOut.html" title="class in oracle.streams">XStreamOut</a> attach(oracle.jdbc.OracleConnection oconn,
                                java.lang.String serverName,
                                byte[] lastPosition,
                                int mode)
                         throws <a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></pre>
<div class="block">Attaches to outbound server.<br>
This API attaches the client to the specified XStream outbound server. This API is also the factory method that returns an XStreamOut instance once it is attached to a valid XStream outbound server.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>oconn</code> - Oracle database connection.<br>
Note that the connection must be made using Oracle OCI (thick) driver.<br></dd>
<dd><code>serverName</code> - Name of the XStream outbound server.<br></dd>
<dd><code>lastPosition</code> - Position that establishes the starting point of the stream. An exception is thrown if the specified position is non-NULL and less than the outbound server's processed low watermark. Otherwise, LCRs with positions greater than the specified position are sent to the client.<br></dd>
<dd><code>mode</code> - The mode of XStream outbound server (for future extension). Valid modes are<br>
XStreamOut.ATTACH_APP_CONTAINER_MODE and<br>
XStreamOut.ATTACH_EXTENDED_ID_MODE. These modes can be added<br>
together.<br></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an XStreamOut instance.<br></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></code> - if error occurs during attach.</dd>
</dl>
</li>
</ul>
<a name="attach_oracle_jdbc_OracleConnection_java_lang_String_byte_A_int_int_int_" id="attach_oracle_jdbc_OracleConnection_java_lang_String_byte_A_int_int_int_"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>attach</h4>
<pre>public static <a href="XStreamOut.html" title="class in oracle.streams">XStreamOut</a> attach(oracle.jdbc.OracleConnection oconn,
                                java.lang.String serverName,
                                byte[] lastPosition,
                                int batchInterval,
                                int idleTimeout,
                                int mode)
                         throws <a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></pre>
<div class="block">Attaches to outbound server.<br>
This API is the same as the other attach API except that is includes the batchInterval and idleTimeout parameters.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>oconn</code> - Oracle database connection.<br>
Note that the connection must be made using Oracle OCI (thick) driver.<br></dd>
<dd><code>serverName</code> - name of the XStream outbound server.<br></dd>
<dd><code>lastPosition</code> - Position that establishes the starting point of the stream. An exception is thrown if the specified position is non-NULL and less than the outbound server's processed low watermark. Otherwise, LCRs with positions greater than the specified position are sent to the client.<br></dd>
<dd><code>batchInterval</code> - XStreamOut batch processing interval.<br></dd>
<dd><code>idleTimeout</code> - XStreamOut idle timeout value.<br></dd>
<dd><code>mode</code> - The mode of XStream outbound server (for future extension). Use XStreamOut.DEFAULT_MODE for now.<br></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an XStreamOut instance.<br></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></code> - if error occurs during attach.</dd>
</dl>
</li>
</ul>
<a name="detach_int_" id="detach_int_"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>detach</h4>
<pre>public void detach(int mode)
            throws <a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></pre>
<div class="block">Detaches from outbound server.<br>
This API detaches the client from the XStream outbound server.<br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mode</code> - The mode of XStream outbound server (for future extension). Use XStreamOut.DEFAULT_MODE for now.<br></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></code> - if error occurs during detach.</dd>
</dl>
</li>
</ul>
<a name="receiveLCRCallback_oracle_streams_XStreamLCRCallbackHandler_int_" id="receiveLCRCallback_oracle_streams_XStreamLCRCallbackHandler_int_"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>receiveLCRCallback</h4>
<pre>public void receiveLCRCallback(<a href="XStreamLCRCallbackHandler.html" title="interface in oracle.streams">XStreamLCRCallbackHandler</a> handler,
                               int mode)
                        throws <a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></pre>
<div class="block">Receives a stream of LCRs in callback mode.<br>
<br>
This API starts LCR streaming from the specified XStream outbound server. You must specify an LCR callback handler that processes each LCR. See more details about LCR callback handlers in XStreamLCRCallbackHandler. For each LCR received, the callback method processLCR() in the given XStreamLCRCallbackHandler is invoked. If chunk data exists in the LCRs, the callback method processChunk() in the given XStreamLCRCallbackHandler is invoked.<br>
<br>
To reduce network roundtrip overhead, for each ReceiveLCRCallback call, XStream also starts a batch process to fill the network buffer with LCRs. The batch process is stopped at a transaction boundary after 30 seconds or after one second if the system is idle. ReceiveLCRCallback does not return until one batch process ends.<br>
<br>
To receive LCRs with only new columns in the new value list, COLUMN_NEW_ONLY_MODE can be set in the mode flag,
<pre>
   int mode = XStreamOut.DEFAULT_MODE | XStreamOut.COLUMN_NEW_ONLY_MODE;
 </pre>
By default XStreamOut returns the union of new columns and old columns that are not present in the new column list.<br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>handler</code> - The XStreamLCRCallbackHandler for handling the LCRs.<br></dd>
<dd><code>mode</code> - A bit flag indicates the mode of XStream outbound server. There are two supported modes currently, DEFAULT_MODE and COLUMN_NEW_ONLY_MODE</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></code> - if error occurs during the entire batch.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="XStreamLCRCallbackHandler.html" title="interface in oracle.streams"><code>XStreamLCRCallbackHandler</code></a></dd>
</dl>
</li>
</ul>
<a name="receiveLCR_int_" id="receiveLCR_int_"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>receiveLCR</h4>
<pre>public <a href="LCR.html" title="interface in oracle.streams">LCR</a> receiveLCR(int mode)
               throws <a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></pre>
<div class="block">Receives one LCR in non-callback mode.<br>
<br>
This method receives one LCR in the stream from the connected outbound server. To avoid network roundtrip for every ReceiveLCR call, XStream still uses batch processing to fill up the network buffer with LCRs. The batch is stopped at a transaction boundary after 30 seconds or after one second if the system is idle.<br>
<br>
You should use getBatchStatus API after receiveLCR call to check the status of batch processing.<br>
To receive LCRs with only new columns in the new value list, COLUMN_NEW_ONLY_MODE can be set in the mode flag,
<pre>
   int mode = XStreamOut.DEFAULT_MODE | XStreamOut.COLUMN_NEW_ONLY_MODE;
 </pre>
By default XStreamOut returns the union of new columns and old columns that are not present in the new column list.<br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mode</code> - A bit flag indicates the mode of XStream outbound server . There are two supported modes currently, DEFAULT_MODE and COLUMN_NEW_ONLY_MODE</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An LCR object.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></code> - if error occurs while receiving an LCR</dd>
</dl>
</li>
</ul>
<a name="receiveChunk_int_" id="receiveChunk_int_"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>receiveChunk</h4>
<pre>public <a href="ChunkColumnValue.html" title="interface in oracle.streams">ChunkColumnValue</a> receiveChunk(int mode)
                              throws <a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></pre>
<div class="block">Receives chunk data in non-callback mode.<br>
This API retrieves streaming LOB, LONG, or XMLTYPE chunk data. Call this method after the receiveLCR() call when the received LCR contains chunk data. All the chunks from one LOB column are returned entirely before switching to the next LOB column.<br>
There is no fixed ordering when LOB columns are returned. You must check the column name to determine the column to which the chunk belongs. Use the the isLastChunk() method in ChunkColumnValue to determine when the last chunk of a LOB column is returned.<br>
Use the isEndOfRow() method in ChunkColumnValue to determine if the last chunk of entire row change has been returned.<br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mode</code> - The mode of XStream outbound server (for future extension). Use XStreamOut.DEFAULT_MODE for now.<br></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A ChunkColumnValue object contains the chunked column data.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></code> - If error occurs while receiving chunk data or constructing a ChunkColumnValue object.</dd>
</dl>
</li>
</ul>
<a name="getBatchStatus__" id="getBatchStatus__"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>getBatchStatus</h4>
<pre>public int getBatchStatus()</pre>
<div class="block">Gets batch status.<br>
This method is used to get the status of XStreamOut batch processing in non-callback mode. The return value can be either EXECUTING or FINISHED. See receiveLCR and receiveLCRCallback for more information about batch process in XStreamOut.<br>
When the status is EXECUTING, the current connection associated with XStreamOut is in use for batch receiving the LCRs from outbound server. Therefore, this connection cannot be used for other JDBC calls. When the status is FINISHED, the connection is available for use.<br>
The batch status is updated whenever the receiveLCR() method is invoked.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The XStreamOut batch processing status</dd>
</dl>
</li>
</ul>
<a name="getFetchLowWatermark__" id="getFetchLowWatermark__"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>getFetchLowWatermark</h4>
<pre>public byte[] getFetchLowWatermark()</pre>
<div class="block">Gets fetch low watermark.<br>
This API gets the outbound server's FetchLowWatermark. The FetchLowWatermark denotes that the outbound server has processed all LCRs with positions lower than or equal to this value. This method can be used to increase the position maintained on the client when the system is idle. When the system is actively streaming LCRs, you can maintain the low watermark using received LCRs.<br></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The outbound server's FetchLowWatermark</dd>
</dl>
</li>
</ul>
<a name="setProcessedLowWatermark_byte_A_int_" id="setProcessedLowWatermark_byte_A_int_"><!--   --></a>
<ul class="blockList">
<li class="blockList">
<h4>setProcessedLowWatermark</h4>
<pre>public void setProcessedLowWatermark(byte[] processedLowWatermark,
                                     int mode)
                              throws <a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></pre>
<div class="block">Sets processed low watermark.<br>
The ProcessedLowWatermark denotes that all LCRs at or below this watermark have been processed by the client. This ProcessedLowWatermark is sent to the outbound server periodically so that archived redo logs containing already processed transactions can be purged. You can call this method anytime between attach and detach calls.<br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>processedLowWatermark</code> - The client's processed low watermark.<br></dd>
<dd><code>mode</code> - The mode of XStream outbound server (for future extension). Use XStreamOut.DEFAULT_MODE for now.<br></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></code> - if error occurs while setting the low watermark.</dd>
</dl>
</li>
</ul>
<a name="setProcessedLowWatermark_byte_A_byte_A_int_" id="setProcessedLowWatermark_byte_A_byte_A_int_"><!--   --></a>
<ul class="blockListLast">
<li class="blockList">
<h4>setProcessedLowWatermark</h4>
<pre>public void setProcessedLowWatermark(byte[] processedLowWatermark,
                                     byte[] oldestPosition,
                                     int mode)
                              throws <a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></pre>
<div class="block">Sets processed low watermark.<br>
The ProcessedLowWatermark denotes that all LCRs at or below this watermark have been processed by the client. This ProcessedLowWatermark is sent to the outbound server periodically so that archived redo logs containing already processed transactions can be purged. You can call this method anytime between attach and detach calls.<br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>processedLowWatermark</code> - The client's processed low watermark.<br></dd>
<dd><code>oldestPosition</code> - The client's oldest position.<br></dd>
<dd><code>mode</code> - The mode of XStream outbound server (for future extension). Use XStreamOut.DEFAULT_MODE for now.<br></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="StreamsException.html" title="class in oracle.streams">StreamsException</a></code> - if error occurs while setting the low watermark.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom" id="navbar_bottom"><!--   --></a>
<div class="skipNav"><a href="#skip_navbar_bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar_bottom_firstrow" id="navbar_bottom_firstrow"><!--   --></a>
<ul class="navList" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><b>Oracle® Database XStream Java API Reference<br>
19c</b><br>
E96285-02</div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="XStreamLCRCallbackHandler.html" title="interface in oracle.streams"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="XStreamUtility.html" title="class in oracle.streams"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html" target="_top">Frames</a></li>
<li><a href="XStreamOut.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript">
<!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script></div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip_navbar_bottom" id="skip_navbar_bottom"><!--   --></a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"></p>
<center><small>Copyright © 2001, 2019, Oracle and/or its affiliates. All Rights Reserved.</small></center>
</body>
</html>
